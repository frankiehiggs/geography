# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_points.ipynb.

# %% auto 0
__all__ = ['in_hull', 'Points']

# %% ../nbs/02_points.ipynb 3
from typing import Literal, Optional
from fastcore.basics import patch
import functools

import numpy as np
from scipy.spatial import ConvexHull

# %% ../nbs/02_points.ipynb 4
def in_hull(point:np.array,  # 1d array 
            hull:ConvexHull, # see scipy.spatial
            tol=1e-9): 
    """checks whether point is inside hull"""
    assert len(point)==hull.ndim, "expect point, hull in the same dimension"
    W,b = hull.equations[:,:-1], hull.equations[:,-1]
    return np.all(W@point+b<=tol)

# %% ../nbs/02_points.ipynb 5
class Points:
    """define binomial or poisson point process in a convex polytope"""
    def __init__(self, n:int, # (expected) number of points 
                d=2,  # dimensionality
                seed: Optional[int]=None, 
                law: Literal["binomial","poisson"]="binomial", # distribution of the points 
                shape: Optional[ConvexHull]=None): # sample from shape, default to unit box
        assert law in ["binomial","poisson"]
        self.rng = np.random.default_rng(seed)
        self.n = self.rng.poisson(n) if law == "poisson" else n
        self.d = d
        self.shape = shape
    
    @functools.cached_property
    def points(self):
        """actually generate points from the prescribed distribution"""
        if self.shape is None: # unit cube
            return self.rng.uniform(size=(self.n,self.d))
        else:
            ps = []
            for _ in range(self.n):
                while True:
                    # must mint new point, no seed passed
                    sample = np.random.default_rng().uniform(self.shape.min_bound, self.shape.max_bound,(self.d,))                     
                    if in_hull(sample, self.shape): ps.append(sample); break
            assert len(ps)==self.n
            return np.array(ps)
        
    @functools.cached_property
    def distance_matrix(self):
        ps = self.points
        diff = ps[:,None,:] - ps[None,:,:]
        dm =  np.linalg.norm(diff,axis=-1)
        return dm

# %% ../nbs/02_points.ipynb 10
@patch
def lnnl(self:Points,k:int=1):
    """computes largest k-nearest neighbour link"""
    ds = self.distance_matrix
    idx = np.argpartition(ds,k,-1)[:,k] # j-th col of argpartiion gives indices of j-th smallest of each row   
    return ds[np.arange(self.n),idx].max()

# %% ../nbs/02_points.ipynb 12
@patch
def connectivity_threshold(self:Points, output_lnnl=False):
    s = self.rng.choice(self.n)
    component = np.zeros(self.n,dtype=bool)
    component[s]=True
    lnnl = r = self.lnnl()
    dm = self.distance_matrix
    while True:
        # collect vertices within distance r from component
        t =  np.max(dm[component]<=r,axis=0)
        if np.any(t>component): # if discover new things: add them to component
            component[t]=True
            if np.all(component): break
        else: # bfs done, component is a cluster; compute its distance to others 
            r = dm[component][:,~component].min()
    return r if not output_lnnl else (lnnl,r)

# %% ../nbs/02_points.ipynb 17
@patch
def get_simplices(self:Points):
    """
    Returns a list of all the (d-1)-dimensional simplices
    in the Cech complex with given Points and with radius r.
    Or perhaps all the "valid" simplices, meaning that the unique point
    in the (d-1)-dimensional hyperplace passing through all d vertices
    which is equidistant to all d vertices
    lies within the simplex itself.
    If this condition isn't met then the set of points which are distance r
    from each of the vertices is either empty or infinite.
    For a valid simplex, on the other hand, there are exactly two such points.

    It should also return the centre, and maybe the normal to the hyperplane passing through the d verticles
    for each valid simplex in the list.
    """
    # First, we choose an r so that the union of balls of radius r/2 covers self.shape.
    # When d=2 we have an upper bound which holds with very high probability
    # that doesn't depend (to first order) on the geometry of the polytope,
    # but in higher dimensions it will. (Penrose "Random Euclidean coverage from within", Thms 3.2 and 3.3)
    # For d>3 we don't even have a formula for the first-order term, although I suspect it will be
    # 2^d times the coverage threshold, for which we do have asymptotics.
    # (Penrose, Yang, Higgs "Largest nearest-neighbour link and connectivity threshold in a polytopal random sample")
    r = self.connectivity_threshold() * 4**self.d # This should hopefully be larger than the coverage threshold with very high probability.
    # Get a list of edges
    mask = self.distance_matrix < r
    return {i: [j for j,v in enumerate(row) if v and j > i] for i,row in enumerate(mask)}
    if self.d == 2:
        # Every edge is valid, so this is simpler. We just need to return the midpoints and normals, but this is also simple.
        pass
    else:
        pass

# %% ../nbs/02_points.ipynb 21
@patch
def coverage_threshold(self:Points):
    """
    Finds the coverage threshold: the smallest r such that the union of balls of radius r
    centred at self.points covers self.shape.
    Uses the new method described above.
    """
    if self.d == 2:
        pass
    else:
        pass
