# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_points.ipynb.

# %% auto 0
__all__ = ['in_hull', 'Points']

# %% ../nbs/02_points.ipynb 3
from typing import Literal, Optional
from fastcore.basics import patch
import functools

import numpy as np
from scipy.spatial import ConvexHull

# %% ../nbs/02_points.ipynb 4
def in_hull(point:np.array,  # 1d array 
            hull:ConvexHull, # see scipy.spatial
            tol=1e-9): 
    """checks whether point is inside hull"""
    assert len(point)==hull.ndim, "expect point, hull in the same dimension"
    W,b = hull.equations[:,:-1], hull.equations[:,-1]
    return np.all(W@point+b<=tol)

# %% ../nbs/02_points.ipynb 5
class Points:
    """define binomial or poisson point process in a convex polytope"""
    def __init__(self, n:int, # (expected) number of points 
                d=2,  # dimensionality
                seed: Optional[int]=None, 
                law: Literal["binomial","poisson"]="binomial", # distribution of the points 
                shape: Optional[ConvexHull]=None): # sample from shape, default to unit box
        assert law in ["binomial","poisson"]
        self.rng = np.random.default_rng(seed)
        self.n = self.rng.poisson(n) if law == "poisson" else n
        self.d = d
        self.shape = shape
    
    @functools.cached_property
    def points(self):
        """actually generate points from the prescribed distribution"""
        if self.shape is None: # unit cube
            return self.rng.uniform(size=(self.n,self.d))
        else:
            ps = []
            for _ in range(self.n):
                while True:
                    # must mint new point, no seed passed
                    sample = np.random.default_rng().uniform(self.shape.min_bound, self.shape.max_bound,(self.d,))                     
                    if in_hull(sample, self.shape): ps.append(sample); break
            assert len(ps)==self.n
            return np.array(ps)
        
    @functools.cached_property
    def distance_matrix(self):
        ps = self.points
        diff = ps[:,None,:] - ps[None,:,:]
        dm =  np.linalg.norm(diff,axis=-1)
        np.fill_diagonal(dm,np.inf)
        return dm

# %% ../nbs/02_points.ipynb 10
@patch
def lnnl(self:Points,k:int=1):
    """computes largest k-nearest neighbour link"""
    ds = self.distance_matrix
    idx = np.argpartition(ds,k-1,-1)[:,k-1] # j-th col of argpartiion gives indices of j-th smallest of each row   
    return ds[np.arange(self.n),idx].max()

# %% ../nbs/02_points.ipynb 12
@patch
def connectivity_threshold(self:Points, output_lnnl=False):
    s = self.rng.choice(self.n)
    component = np.zeros(self.n,dtype=bool)
    component[s]=True
    lnnl = r = self.lnnl()
    dm = self.distance_matrix
    dm_ma = np.ma.array(dm,mask=np.tile(component,(self.n,1)))
    while True:
        # collect vertices within distance r from component
        t =  np.max(dm_ma[component]<=r,0)
        if np.any(t): 
            # if discover new things: add them to component; mask more cols
            component[t]=True
            if np.all(component): break
            dm_ma.mask = np.tile(component,(self.n,1))
        else: 
            # bfs done, component is a cluster; compute its distance to others 
            r=dm_ma[component].min()
    return r if not output_lnnl else (lnnl,r)
